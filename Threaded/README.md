## multi-Threaded

Java 是一個支援多線程 (multi-threaded) 的語言，這代表著 Java 程序可以同時執行多個任務 (tasks)。   
在 Java 中，每個線程都是獨立運行的，擁有自己的堆棧空間，可以同時進行不同的操作。     

多線程的好處在於它可以使程序更加高效和靈活。   
當一個線程遇到耗時的任務時，其他線程可以繼續執行而不必等待該任務完成。   
這樣可以讓程序在相同的時間內完成更多的工作。   
此外，多線程也可以用於提高程序的可靠性，例如在一個線程出現異常或錯誤時，其他線程仍然可以繼續執行。   

### Thread Pool
Thread pool 是一個可以重複使用的執行緒集合，被用來執行任務。一旦建立了一個固定大小的 thread pool，便可以將任務提交到池中執行，這些任務將被分配給池中的某一個執行緒去執行，當任務執行完畢後，執行緒會被釋放回池中以供重複使用。這樣可以避免重複創建和銷毀執行緒的開銷，以及減少了同時運行的執行緒數量，從而提高了系統效能。   

* 執行語法
```js
// 建立大小為5的固定thread-pool
ExecutorService executor = Executors.newFixedThreadPool(5));

// 不再需要使用thread，可以通過 shutdown() 方法將其關閉。
executor.shutdown();
```

### Race Condition
當多個進程或執行緒在並發執行時，如果它們競爭訪問共享資源或對同一資源進行寫操作時，就可能發生race condition（競爭條件）。   
Race condition通常是由於未正確同步並發執行的程序或沒有適當處理共享資源的互斥機制引起的。為了避免race condition，需要對共享資源進行適當的同步，例如使用互斥鎖或信號量等機制。   

* Main.java    
    Main.java是一段有競爭狀態問題的程式，使用兩種方法解決這個困擾。

* Lock.java    
    lock.lock() 是用來取得鎖，防止多個執行緒操作。如果鎖已經被另一個執行緒獲取，則當前執行緒會被阻塞，直到鎖被釋放為止。   
    lock.unlock() 是用來釋放鎖的，以便其他執行緒可以繼續操作。如果不釋放鎖，其他執行緒就無法繼續操作，導致程式停滯。   

* Synchronized.java      
    方法被加上了 synchronized 關鍵字，因此當多個線程同時調用該方法時，只有一個線程能夠進入該方法執行。其他線程會等待，直到進入該方法的線程執行完畢並釋放鎖為止。這樣可以避免多個線程同時操作，導致競爭條件的問題。    

### Collaboration   
這是一個簡單的銀行帳戶模擬系統，包含兩個任務：存款任務和取款任務。   
透過線程池中的執行緒來執行這些任務。   
使用了 Java 的 Lock 和 Condition 機制來實現同步和互斥控制。   
Account 類別包含了存款和取款的方法。在執行這些方法時，它們使用 ReentrantLock 來取得互斥鎖，以防止多個線程同時對帳戶進行操作。   


### PCP
PCP (Producer & Comsumer Problem)